// Package attention provides integration tests for attention mechanisms.
//
// These tests verify that the Go implementation matches the Python reference
// implementation by comparing against binary test data generated by PyTorch.
package attention

import (
	"math"
	"os"
	"path/filepath"
	"testing"

	"gollm/pkg/model"
	"gollm/pkg/model/testutil"
	"gollm/pkg/tensor"
)

// findTestDataDir finds the testdata directory from the project root.
func findTestDataDir(t *testing.T) string {
	// Try to find testdata directory
	// Start from current directory and go up
	dir, _ := os.Getwd()
	for {
		testdata := filepath.Join(dir, "testdata", "attention")
		if _, err := os.Stat(testdata); err == nil {
			return testdata
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	// Fallback: assume we're in the model directory
	return "../../testdata/attention"
}

// TestCausalSelfAttention_AgainstPython verifies CausalSelfAttention matches Python output.
func TestCausalSelfAttention_AgainstPython(t *testing.T) {
	testdata := findTestDataDir(t)

	// Load input and weights from Python
	x, err := testutil.LoadTensor(filepath.Join(testdata, "causal_input.bin"), []int{2, 10, 768})
	if err != nil {
		t.Fatalf("Failed to load input: %v", err)
	}

	wQ, err := testutil.LoadTensor(filepath.Join(testdata, "causal_w_q.bin"), []int{768, 768})
	if err != nil {
		t.Fatalf("Failed to load WQuery: %v", err)
	}

	wK, err := testutil.LoadTensor(filepath.Join(testdata, "causal_w_k.bin"), []int{768, 768})
	if err != nil {
		t.Fatalf("Failed to load WKey: %v", err)
	}

	wV, err := testutil.LoadTensor(filepath.Join(testdata, "causal_w_v.bin"), []int{768, 768})
	if err != nil {
		t.Fatalf("Failed to load WValue: %v", err)
	}

	expected, err := testutil.LoadTensor(filepath.Join(testdata, "causal_expected.bin"), []int{2, 10, 768})
	if err != nil {
		t.Fatalf("Failed to load expected output: %v", err)
	}

	// Create attention with loaded weights
	attn := &CausalSelfAttention{
		WQuery: wQ,
		WKey:   wK,
		WValue: wV,
		DOut:   768,
		Scale:  float32(1.0 / math.Sqrt(768)),
	}

	// Forward pass
	output, err := attn.Forward(x)
	if err != nil {
		t.Fatalf("Forward failed: %v", err)
	}

	// Compare with Python output
	equal, msg := testutil.TensorsEqual(output, expected, 1e-4)
	if !equal {
		t.Errorf("Output doesn't match Python: %s", msg)
		testutil.PrintTensorComparison(output, expected, "CausalSelfAttention", 10)
	}
}

// TestMultiHeadAttention_AgainstPython verifies MultiHeadAttention matches Python output.
func TestMultiHeadAttention_AgainstPython(t *testing.T) {
	testdata := findTestDataDir(t)

	// Load input and weights
	x, err := testutil.LoadTensor(filepath.Join(testdata, "mha_input.bin"), []int{2, 10, 768})
	if err != nil {
		t.Fatalf("Failed to load input: %v", err)
	}

	wQ, err := testutil.LoadTensor(filepath.Join(testdata, "mha_w_q.bin"), []int{768, 768})
	if err != nil {
		t.Fatalf("Failed to load WQuery: %v", err)
	}

	wK, err := testutil.LoadTensor(filepath.Join(testdata, "mha_w_k.bin"), []int{768, 768})
	if err != nil {
		t.Fatalf("Failed to load WKey: %v", err)
	}

	wV, err := testutil.LoadTensor(filepath.Join(testdata, "mha_w_v.bin"), []int{768, 768})
	if err != nil {
		t.Fatalf("Failed to load WValue: %v", err)
	}

	wOut, err := testutil.LoadTensor(filepath.Join(testdata, "mha_w_out.bin"), []int{768, 768})
	if err != nil {
		t.Fatalf("Failed to load OutProj: %v", err)
	}

	expected, err := testutil.LoadTensor(filepath.Join(testdata, "mha_expected.bin"), []int{2, 10, 768})
	if err != nil {
		t.Fatalf("Failed to load expected output: %v", err)
	}

	// Create MHA with loaded weights
	attn := &MultiHeadAttention{
		NumHeads: 12,
		HeadDim:  64,
		DOut:     768,
		DIn:      768,
		Dropout:  0.0,
		WQuery:   wQ,
		WKey:     wK,
		WValue:   wV,
		OutProj:  wOut,
	}

	// Create causal mask
	mask := createCausalMask(10)

	// Forward pass
	output, err := attn.Forward(x, mask, nil)
	if err != nil {
		t.Fatalf("Forward failed: %v", err)
	}

	// Compare with Python output
	equal, msg := testutil.TensorsEqual(output, expected, 1e-4)
	if !equal {
		t.Errorf("Output doesn't match Python: %s", msg)
		testutil.PrintTensorComparison(output, expected, "MultiHeadAttention", 10)
	}
}

// TestGroupedQueryAttention_AgainstPython verifies GQA matches Python output.
func TestGroupedQueryAttention_AgainstPython(t *testing.T) {
	testdata := findTestDataDir(t)

	// Load input and weights
	x, err := testutil.LoadTensor(filepath.Join(testdata, "gqa_input.bin"), []int{2, 10, 768})
	if err != nil {
		t.Fatalf("Failed to load input: %v", err)
	}

	wQ, err := testutil.LoadTensor(filepath.Join(testdata, "gqa_w_q.bin"), []int{768, 768})
	if err != nil {
		t.Fatalf("Failed to load WQuery: %v", err)
	}

	wK, err := testutil.LoadTensor(filepath.Join(testdata, "gqa_w_k.bin"), []int{768, 256})
	if err != nil {
		t.Fatalf("Failed to load WKey: %v", err)
	}

	wV, err := testutil.LoadTensor(filepath.Join(testdata, "gqa_w_v.bin"), []int{768, 256})
	if err != nil {
		t.Fatalf("Failed to load WValue: %v", err)
	}

	wOut, err := testutil.LoadTensor(filepath.Join(testdata, "gqa_w_out.bin"), []int{768, 768})
	if err != nil {
		t.Fatalf("Failed to load OutProj: %v", err)
	}

	expected, err := testutil.LoadTensor(filepath.Join(testdata, "gqa_expected.bin"), []int{2, 10, 768})
	if err != nil {
		t.Fatalf("Failed to load expected output: %v", err)
	}

	// Create GQA with loaded weights
	attn := &GroupedQueryAttention{
		NumHeads:    12,
		NumKVGroups: 4,
		GroupSize:   3,
		HeadDim:     64,
		DOut:        768,
		DIn:         768,
		Dropout:     0.0,
		WQuery:      wQ,
		WKey:        wK,
		WValue:      wV,
		OutProj:     wOut,
	}

	// Create causal mask
	mask := createCausalMask(10)

	// Forward pass
	output, err := attn.Forward(x, mask, nil)
	if err != nil {
		t.Fatalf("Forward failed: %v", err)
	}

	// Compare with Python output
	equal, msg := testutil.TensorsEqual(output, expected, 1e-4)
	if !equal {
		t.Errorf("Output doesn't match Python: %s", msg)
		testutil.PrintTensorComparison(output, expected, "GroupedQueryAttention", 10)
	}
}

// createCausalMask creates an upper triangular causal mask for attention.
// Shape: (seq_len, seq_len), with 1s in lower triangle and 0s in upper triangle.
func createCausalMask(seqLen int) *tensor.Tensor {
	mask := tensor.NewTensor([]int{seqLen, seqLen})
	for i := 0; i < seqLen; i++ {
		for j := 0; j < seqLen; j++ {
			if j <= i {
				mask.Data[i*seqLen+j] = 1
			}
		}
	}
	return mask
}

// TestRoPE_AgainstPython verifies RoPE application matches Python output.
func TestRoPE_AgainstPython(t *testing.T) {
	testdata := findTestDataDir(t)

	// Load test data
	input, err := testutil.LoadTensor(filepath.Join(testdata, "rope_input.bin"), []int{1, 4, 10, 64})
	if err != nil {
		t.Fatalf("Failed to load input: %v", err)
	}

	expected, err := testutil.LoadTensor(filepath.Join(testdata, "rope_expected.bin"), []int{1, 4, 10, 64})
	if err != nil {
		t.Fatalf("Failed to load expected output: %v", err)
	}

	// Create RoPE parameters
	rope := &model.RoPEParams{}

	// Apply RoPE to input (split-halves approach)
	// x1 = input[..., :head_dim/2]
	// x2 = input[..., head_dim/2:]
	// rotated = [-x2, x1]
	// output = input * cos + rotated * sin
	output := applyRoPE(input, rope, 0, 10)

	// Compare with Python output
	equal, msg := testutil.TensorsEqual(output, expected, 1e-5)
	if !equal {
		t.Errorf("RoPE output doesn't match: %s", msg)
		testutil.PrintTensorComparison(output, expected, "RoPE", 10)
	}
}

// applyRoPE applies Rotary Position Embeddings to the input tensor.
// This is a simplified implementation for testing.
func applyRoPE(input *tensor.Tensor, rope *model.RoPEParams, startPos, seqLen int) *tensor.Tensor {
	// This is a placeholder - the actual implementation would use model.ApplyRoPE
	return input.Clone()
}
