// Package testutil provides testing utilities for the gollm model package.
//
// This package contains helper functions for:
// - Loading binary tensor data generated by Python scripts
// - Saving tensors for debugging
// - Comparing tensors with tolerance
// - Printing tensor information
package testutil

import (
	"encoding/binary"
	"fmt"
	"math"
	"os"
	"path/filepath"

	"gollm/pkg/tensor"
)

// LoadTensor loads a binary tensor file saved from Python.
//
// The binary file should contain float32 values in little-endian format,
// as generated by NumPy's tofile() method.
//
// Parameters:
//   - filepath: Path to the binary file
//   - shape: Expected shape of the tensor
//
// Returns:
//   - *tensor.Tensor: Loaded tensor
//   - error: Error if loading fails
//
// Example:
//
//	t, err := LoadTensor("testdata/input.bin", []int{2, 10, 768})
//	if err != nil {
//	    t.Fatalf("Failed to load tensor: %v", err)
//	}
func LoadTensor(filepath string, shape []int) (*tensor.Tensor, error) {
	data, err := os.ReadFile(filepath)
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", filepath, err)
	}

	// Each float32 is 4 bytes
	expectedSize := 1
	for _, dim := range shape {
		expectedSize *= dim
	}
	expectedBytes := expectedSize * 4

	if len(data) != expectedBytes {
		return nil, fmt.Errorf("file size mismatch: expected %d bytes for shape %v, got %d",
			expectedBytes, shape, len(data))
	}

	// Convert bytes to float32
	numFloats := len(data) / 4
	floats := make([]float32, numFloats)
	for i := 0; i < numFloats; i++ {
		bits := binary.LittleEndian.Uint32(data[i*4 : (i+1)*4])
		floats[i] = math.Float32frombits(bits)
	}

	return tensor.NewTensorFromData(floats, shape), nil
}

// SaveTensor saves a tensor to a binary file for debugging.
//
// The file is saved in little-endian float32 format, compatible with
// Python's numpy.fromfile() function.
//
// Parameters:
//   - t: Tensor to save
//   - filepath: Path where to save the file
//
// Returns:
//   - error: Error if saving fails
func SaveTensor(t *tensor.Tensor, path string) error {
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create file %s: %w", path, err)
	}
	defer f.Close()

	for _, v := range t.Data {
		bits := math.Float32bits(v)
		if err := binary.Write(f, binary.LittleEndian, bits); err != nil {
			return fmt.Errorf("failed to write to file: %w", err)
		}
	}

	return nil
}

// TensorsEqual checks if two tensors are equal within a tolerance.
//
// Parameters:
//   - a, b: Tensors to compare
//   - tolerance: Maximum allowed difference between corresponding elements
//
// Returns:
//   - bool: true if tensors are equal within tolerance
//   - string: Error message if not equal
//
// Example:
//
//	equal, msg := TensorsEqual(actual, expected, 1e-5)
//	if !equal {
//	    t.Errorf("Tensors differ: %s", msg)
//	}
func TensorsEqual(a, b *tensor.Tensor, tolerance float32) (bool, string) {
	if a == nil || b == nil {
		if a == nil && b == nil {
			return true, ""
		}
		return false, "one tensor is nil"
	}

	if !shapeEquals(a.Shape, b.Shape) {
		return false, fmt.Sprintf("shape mismatch: %v vs %v", a.Shape, b.Shape)
	}

	if len(a.Data) != len(b.Data) {
		return false, fmt.Sprintf("data length mismatch: %d vs %d", len(a.Data), len(b.Data))
	}

	maxDiff := float64(0)
	diffIndex := -1

	for i := range a.Data {
		diff := math.Abs(float64(a.Data[i] - b.Data[i]))
		if diff > float64(tolerance) {
			if diffIndex == -1 {
				diffIndex = i
			}
			if diff > maxDiff {
				maxDiff = diff
			}
		}
	}

	if diffIndex != -1 {
		return false, fmt.Sprintf(
			"values differ at index %d: %f vs %f (max diff: %f > tolerance: %f)",
			diffIndex, a.Data[diffIndex], b.Data[diffIndex], maxDiff, tolerance)
	}

	return true, ""
}

// shapeEquals checks if two shapes are equal.
func shapeEquals(a, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// TensorStats contains statistics about a tensor for debugging.
type TensorStats struct {
	Shape      []int
	Numel      int
	Min        float32
	Max        float32
	Mean       float32
	Std        float32
	HasNaN     bool
	HasInf     bool
	SampleData []float32
}

// ComputeStats computes statistics for a tensor.
func ComputeStats(t *tensor.Tensor) TensorStats {
	if t == nil || len(t.Data) == 0 {
		return TensorStats{}
	}

	s := TensorStats{
		Shape: t.Shape,
		Numel: len(t.Data),
	}

	// Min, max, sum
	s.Min = t.Data[0]
	s.Max = t.Data[0]
	sum := float64(0)

	for _, v := range t.Data {
		if v < s.Min {
			s.Min = v
		}
		if v > s.Max {
			s.Max = v
		}
		sum += float64(v)

		if math.IsNaN(float64(v)) {
			s.HasNaN = true
		}
		if math.IsInf(float64(v), 0) {
			s.HasInf = true
		}
	}

	s.Mean = float32(sum / float64(len(t.Data)))

	// Standard deviation
	variance := float64(0)
	for _, v := range t.Data {
		diff := float64(v) - float64(s.Mean)
		variance += diff * diff
	}
	s.Std = float32(math.Sqrt(variance / float64(len(t.Data))))

	// Sample data (first 10 elements or fewer)
	sampleSize := 10
	if len(t.Data) < sampleSize {
		sampleSize = len(t.Data)
	}
	s.SampleData = make([]float32, sampleSize)
	copy(s.SampleData, t.Data[:sampleSize])

	return s
}

// PrintTensor prints tensor shape and statistics.
//
// Parameters:
//   - t: Tensor to print
//   - name: Name label for the tensor
func PrintTensor(t *tensor.Tensor, name string) {
	if t == nil {
		fmt.Printf("%s: nil\n", name)
		return
	}

	stats := ComputeStats(t)
	fmt.Printf("%s:\n", name)
	fmt.Printf("  Shape: %v\n", stats.Shape)
	fmt.Printf("  Elements: %d\n", stats.Numel)
	fmt.Printf("  Range: [%f, %f]\n", stats.Min, stats.Max)
	fmt.Printf("  Mean: %f, Std: %f\n", stats.Mean, stats.Std)
	if stats.HasNaN {
		fmt.Printf("  WARNING: Contains NaN values!\n")
	}
	if stats.HasInf {
		fmt.Printf("  WARNING: Contains Inf values!\n")
	}
	fmt.Printf("  Sample: %v\n", stats.SampleData)
}

// PrintTensorComparison prints side-by-side comparison of two tensors.
func PrintTensorComparison(actual, expected *tensor.Tensor, name string, maxElements int) {
	fmt.Printf("\n=== %s Comparison ===\n", name)

	actualStats := ComputeStats(actual)
	expectedStats := ComputeStats(expected)

	fmt.Printf("Actual:   shape=%v, range=[%.6f, %.6f], mean=%.6f\n",
		actualStats.Shape, actualStats.Min, actualStats.Max, actualStats.Mean)
	fmt.Printf("Expected: shape=%v, range=[%.6f, %.6f], mean=%.6f\n",
		expectedStats.Shape, expectedStats.Min, expectedStats.Max, expectedStats.Mean)

	// Print sample values side-by-side
	fmt.Printf("\nFirst %d elements:\n", maxElements)
	n := len(actual.Data)
	if len(expected.Data) < n {
		n = len(expected.Data)
	}
	if maxElements < n {
		n = maxElements
	}

	for i := 0; i < n; i++ {
		diff := math.Abs(float64(actual.Data[i] - expected.Data[i]))
		marker := " "
		if diff > 1e-5 {
			marker = "*" // Mark significant differences
		}
		fmt.Printf("  [%3d] actual=%.8f, expected=%.8f, diff=%.2e %s\n",
			i, actual.Data[i], expected.Data[i], diff, marker)
	}

	if n < len(actual.Data) {
		fmt.Printf("  ... (%d more elements)\n", len(actual.Data)-n)
	}
}

// FindTestDataDir attempts to find the testdata directory.
// It searches from the current directory up to the project root.
func FindTestDataDir(subdir string) (string, error) {
	// Try current directory first
	if _, err := os.Stat(subdir); err == nil {
		return subdir, nil
	}

	// Walk up the directory tree
	for dir := "."; ; {
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent

		testdataPath := filepath.Join(dir, subdir)
		if _, err := os.Stat(testdataPath); err == nil {
			return testdataPath, nil
		}
	}

	return "", fmt.Errorf("testdata directory not found: %s", subdir)
}
